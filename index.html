<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcane Somatic | Magician's Studio</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        :root {
            --mana: #00f2ff;
            --fire: #ff4e00;
            --void: #9d00ff;
            --gold: #ffcc00;
            --glass: rgba(10, 10, 25, 0.7);
            --border: rgba(0, 242, 255, 0.3);
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background: #000;
            font-family: 'Cinzel', serif; color: white;
        }

        #app { position: relative; width: 100vw; height: 100vh; display: none; }
        #output_canvas { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        /* HUD Overlay */
        .hud-overlay {
            position: absolute; inset: 0; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 30px; box-sizing: border-box;
            transition: background 0.3s ease;
            z-index: 10;
        }

        /* Arcane Vignette for Depth */
        .vignette {
            position: absolute; inset: 0;
            background: radial-gradient(circle, transparent 40%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: 5;
            box-shadow: inset 0 0 100px rgba(0, 242, 255, 0.1);
            transition: box-shadow 0.5s ease;
        }

        .header { 
            display: flex; 
            justify-content: space-between; 
            align-items: flex-start;
            width: 100%;
        }
        
        .ritual-info {
            background: var(--glass); 
            padding: 25px; 
            border-radius: 0 0 40px 0;
            border-bottom: 2px solid var(--mana);
            border-right: 2px solid var(--mana);
            backdrop-filter: blur(20px);
            box-shadow: 0 0 40px rgba(0, 242, 255, 0.15);
            position: relative;
        }

        .spell-title { 
            font-size: 32px; 
            letter-spacing: 8px; 
            color: var(--gold); 
            text-transform: uppercase; 
            margin-bottom: 12px; 
            font-weight: 700;
            text-shadow: 0 0 15px rgba(255, 204, 0, 0.4);
        }

        .mana-meter { 
            width: 280px; 
            height: 4px; 
            background: rgba(255,255,255,0.1); 
            overflow: hidden; 
            border-radius: 2px;
        }
        .mana-fill { 
            height: 100%; 
            width: 100%; 
            background: linear-gradient(90deg, #0080ff, var(--mana), #fff); 
            box-shadow: 0 0 10px var(--mana);
            animation: manaPulse 2s ease-in-out infinite;
        }

        @keyframes manaPulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .log-container {
            align-self: flex-start; 
            width: 300px;
            font-size: 11px; 
            font-family: 'Courier New', monospace; 
            color: var(--mana);
            background: rgba(0,0,0,0.6); 
            padding: 20px; 
            border-radius: 12px;
            border: 1px solid var(--border);
            backdrop-filter: blur(5px);
        }

        .log-line { margin-bottom: 4px; opacity: 0.8; border-bottom: 1px solid rgba(0, 242, 255, 0.1); padding-bottom: 2px; }

        .gesture-legend {
            position: absolute; 
            bottom: 40px; 
            left: 50%; 
            transform: translateX(-50%);
            display: flex; 
            gap: 40px; 
            background: var(--glass);
            padding: 15px 50px; 
            border-radius: 100px; 
            border: 1px solid var(--border);
            backdrop-filter: blur(15px);
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        .gesture-item { 
            display: flex; 
            align-items: center; 
            gap: 12px; 
            font-size: 13px; 
            letter-spacing: 2px; 
            color: #aaa;
            text-transform: uppercase;
        }
        .gesture-item b { color: var(--mana); font-weight: 700; }

        /* Login Screen */
        #gate {
            position: fixed; inset: 0; z-index: 1000;
            background: radial-gradient(circle at center, #050515 0%, #000 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        .gate-ring {
            width: 320px; height: 320px; border: 1px solid var(--mana);
            border-radius: 50%; animation: rotate 40s linear infinite;
            display: flex; align-items: center; justify-content: center;
            opacity: 0.5;
        }

        @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        .gate-btn {
            position: absolute; background: none; border: 1px solid var(--mana);
            color: var(--mana); padding: 20px 70px; cursor: pointer;
            font-family: 'Cinzel'; letter-spacing: 8px; font-size: 22px;
            transition: all 0.5s ease;
        }
        .gate-btn:hover { background: rgba(0, 242, 255, 0.1); box-shadow: 0 0 80px rgba(0, 242, 255, 0.4); transform: scale(1.05); }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

<div id="gate">
    <div class="gate-ring"></div>
    <button class="gate-btn" id="init-btn" onclick="initiate()">INITIATE LINK</button>
</div>

<div id="app">
    <div class="vignette" id="vignette"></div>
    <canvas id="output_canvas"></canvas>
    <div class="hud-overlay" id="hud-overlay">
        <div class="header">
            <div class="ritual-info">
                <div id="active-spell" class="spell-title">Inferno Heart</div>
                <div class="mana-meter"><div class="mana-fill"></div></div>
            </div>
            <div class="log-container" id="arcane-log">
                <div class="log-line">> SOMATIC SYNC... OK</div>
                <div class="log-line">> MANA WELL... STABLE</div>
            </div>
        </div>

        <div class="gesture-legend">
            <div class="gesture-item"><span>üñêÔ∏è</span> <b>EMIT</b></div>
            <div class="gesture-item"><span>‚úä</span> <b>THROW BOLT</b></div>
            <div class="gesture-item"><span>‚úåÔ∏è</span> <b>CYCLE</b></div>
            <div class="gesture-item"><span>üò≤</span> <b>RIFT BREATH</b></div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('output_canvas');
    const ctx = canvas.getContext('2d');
    const log = document.getElementById('arcane-log');
    const hud = document.getElementById('hud-overlay');
    const vignette = document.getElementById('vignette');
    const videoElement = document.createElement('video');
    videoElement.setAttribute('playsinline', '');

    const SPELLS = [
        { name: "Inferno Heart", color: "#ff4e00", secondary: "#ffcc00", type: "fire" },
        { name: "Celestial Mass", color: "#00f2ff", secondary: "#ffffff", type: "rock" },
        { name: "Abyssal Void", color: "#9d00ff", secondary: "#4b0082", type: "void" }
    ];

    let currentSpellIdx = 0;
    let particles = [];
    let wisps = []; // Environmental particles
    let cooldowns = { switch: false, bolt: {} };
    
    let handsState = [
        { lastPos: { x: 0, y: 0 }, velocity: { x: 0, y: 0 }, isClosed: false, active: false },
        { lastPos: { x: 0, y: 0 }, velocity: { x: 0, y: 0 }, isClosed: false, active: false }
    ];

    let mouthState = { 
        isOpen: false, 
        pos: { x: 0, y: 0 }, 
        scale: 0, 
        rotation: 0,
        faceLandmarks: null 
    };

    const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
    hands.onResults(handleHands);

    const faceMesh = new FaceMesh({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
    faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    faceMesh.onResults(handleFace);

    function addLog(msg) {
        const newLine = document.createElement('div');
        newLine.className = 'log-line';
        newLine.innerText = `> ${msg.toUpperCase()}`;
        log.prepend(newLine);
        if (log.children.length > 4) log.removeChild(log.lastChild);
    }

    function handleFace(results) {
        if (!results.multiFaceLandmarks?.length) {
            mouthState.isOpen = false;
            mouthState.faceLandmarks = null;
            return;
        }
        const landmarks = results.multiFaceLandmarks[0];
        mouthState.faceLandmarks = landmarks;
        
        const dist = Math.abs(landmarks[13].y - landmarks[14].y);
        
        mouthState.pos = {
            x: (1 - landmarks[13].x) * canvas.width,
            y: landmarks[13].y * canvas.height
        };

        if (dist > 0.05) { // Sensitivity threshold
            if (!mouthState.isOpen) {
                addLog("ARCANE RIFT OPENED");
                hud.style.background = "rgba(0,0,0,0.6)"; // More transparent background
                vignette.style.boxShadow = `inset 0 0 150px ${SPELLS[currentSpellIdx].color}`;
            }
            mouthState.isOpen = true;
            mouthState.scale = 1.0; 
            mouthState.rotation += 0.05;
            
            for(let i=0; i<3; i++) {
                spawnFireBreath(mouthState.pos.x, mouthState.pos.y);
            }
        } else {
            if (mouthState.isOpen) {
                hud.style.background = "transparent";
                vignette.style.boxShadow = "inset 0 0 100px rgba(0, 242, 255, 0.1)";
            }
            mouthState.isOpen = false;
            mouthState.scale = 0; 
        }
    }

    function handleHands(results) {
        handsState[0].active = false;
        handsState[1].active = false;

        if (!results.multiHandLandmarks?.length) return;

        results.multiHandLandmarks.forEach((lm, index) => {
            const hIdx = index;
            handsState[hIdx].active = true;
            const tip = lm[8], mid = lm[12], ring = lm[16], pinky = lm[20];
            
            const mx = (1 - tip.x) * canvas.width;
            const my = tip.y * canvas.height;

            handsState[hIdx].velocity = { x: mx - handsState[hIdx].lastPos.x, y: my - handsState[hIdx].lastPos.y };
            handsState[hIdx].lastPos = { x: mx, y: my };

            const isVictory = (tip.y < lm[6].y && mid.y < lm[10].y && ring.y > lm[14].y && pinky.y > lm[18].y);
            const isClosed = (tip.y > lm[6].y && mid.y > lm[10].y && ring.y > lm[14].y);
            const isOpenHand = (tip.y < lm[6].y && mid.y < lm[10].y && ring.y < lm[14].y && pinky.y < lm[18].y);

            if (isVictory && !cooldowns.switch) {
                currentSpellIdx = (currentSpellIdx + 1) % SPELLS.length;
                const s = SPELLS[currentSpellIdx];
                document.getElementById('active-spell').innerText = s.name;
                document.getElementById('active-spell').style.color = s.color;
                cooldowns.switch = true;
                addLog(`ELEMENT: ${s.type}`);
                setTimeout(() => cooldowns.switch = false, 800);
                return;
            }

            if (isClosed) {
                if (!handsState[hIdx].isClosed && !cooldowns.bolt[hIdx]) {
                    const vel = handsState[hIdx].velocity;
                    const pushX = vel.x * 2 || (Math.random()-0.5)*10;
                    const pushY = vel.y * 2 || -15;
                    
                    spawnProjectiles(mx, my, {x: pushX, y: pushY}, 1.5);
                    addLog(`BOLT RELEASED`);
                    
                    cooldowns.bolt[hIdx] = true;
                    setTimeout(() => cooldowns.bolt[hIdx] = false, 300);
                }
                handsState[hIdx].isClosed = true;
            } else if (isOpenHand) {
                spawnAmbient(mx, my, 3, handsState[hIdx].velocity, 1.0);
                handsState[hIdx].isClosed = false;
            } else {
                handsState[hIdx].isClosed = false;
            }
        });
    }

    function drawMask() {
        if (!mouthState.isOpen || !mouthState.faceLandmarks) return;
        
        const lm = mouthState.faceLandmarks;
        const color = SPELLS[currentSpellIdx].color;
        const time = Date.now() / 1000;

        ctx.save();
        ctx.globalAlpha = 0.8; // Lowered alpha to make face more visible
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.8;
        ctx.shadowBlur = 10;
        ctx.shadowColor = color;

        const getXY = (p) => ({ x: (1 - p.x) * canvas.width, y: p.y * canvas.height });

        // --- SPECTRAL CROWN ---
        const crownBase = [103, 67, 109, 10, 338, 297, 332];
        ctx.beginPath();
        crownBase.forEach((idx, i) => {
            const p = getXY(lm[idx]);
            const offset = Math.sin(time * 2 + i) * 15;
            if (i === 0) ctx.moveTo(p.x, p.y - 40 - offset);
            else ctx.lineTo(p.x, p.y - 40 - offset);
        });
        ctx.stroke();

        // --- FLOATING RUNE TEARS ---
        [101, 330].forEach((cheekIdx, i) => {
            const p = getXY(lm[cheekIdx]);
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x, p.y + 40 + Math.sin(time * 3) * 10);
            ctx.setLineDash([2, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        });

        // --- ORBITAL EYES ---
        [159, 386].forEach((eyeIdx, i) => {
            const p = getXY(lm[eyeIdx]);
            // Subtle pulse instead of solid pupil
            ctx.beginPath();
            ctx.arc(p.x, p.y, 8 + Math.sin(time*8)*3, 0, Math.PI * 2);
            ctx.strokeStyle = "#fff";
            ctx.stroke();
            
            // Outer Concentric Rings
            for(let j=1; j<=2; j++) {
                ctx.beginPath();
                ctx.ellipse(p.x, p.y, 15*j, 25*j, time * (i === 0 ? 1 : -1) + j, 0, Math.PI * 2);
                ctx.stroke();
            }
        });

        // --- THE HEX-GRID (FOREHEAD) ---
        const f = getXY(lm[10]);
        ctx.save();
        ctx.translate(f.x, f.y - 30);
        ctx.rotate(Math.PI/4);
        for(let j=0; j<3; j++) {
            ctx.strokeRect(-10*j, -10*j, 20*j, 20*j);
        }
        ctx.restore();

        // --- CHIN SIGIL ---
        const chin = getXY(lm[152]);
        ctx.save();
        ctx.translate(chin.x, chin.y + 10);
        ctx.beginPath();
        for(let j=0; j<6; j++) {
            const ang = (j/6) * Math.PI * 2;
            ctx.lineTo(Math.cos(ang)*15, Math.sin(ang)*15);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.restore();

        // --- WHISKER RUNES (CHEEKS) ---
        [[123, 147, 213], [352, 376, 433]].forEach((points, i) => {
            ctx.beginPath();
            points.forEach((idx, j) => {
                const p = getXY(lm[idx]);
                if (j === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();
        });

        ctx.restore();
    }

    function drawImmersiveElements() {
        // Subtle Mana Wisps
        if (Math.random() < 0.05) spawnWisp();
        
        wisps.forEach((w, i) => {
            w.y -= w.speed;
            w.x += Math.sin(Date.now() / 1000 + w.offset) * 0.5;
            w.life -= 0.005;
            if (w.life <= 0) wisps.splice(i, 1);
            else {
                ctx.globalAlpha = w.life * 0.3;
                ctx.fillStyle = SPELLS[currentSpellIdx].color;
                ctx.beginPath(); ctx.arc(w.x, w.y, w.size, 0, Math.PI*2); ctx.fill();
            }
        });

        if (!mouthState.isOpen) return;
        
        drawMask();

        const {x, y} = mouthState.pos;
        ctx.save();
        ctx.translate(x, y);
        
        // Rift Ring
        ctx.save();
        ctx.rotate(mouthState.rotation);
        ctx.strokeStyle = SPELLS[currentSpellIdx].color;
        ctx.lineWidth = 3;
        ctx.setLineDash([20, 15]);
        ctx.beginPath(); ctx.arc(0, 0, 90, 0, Math.PI*2); ctx.stroke();
        ctx.restore();

        // Core Rift Glow (Much lighter to see mouth)
        const riftGrad = ctx.createRadialGradient(0,0,0, 0,0, 70);
        riftGrad.addColorStop(0, "rgba(255,255,255,0.4)");
        riftGrad.addColorStop(0.5, SPELLS[currentSpellIdx].secondary + "44"); // 44 is hex alpha
        riftGrad.addColorStop(1, "transparent");
        ctx.fillStyle = riftGrad;
        ctx.globalCompositeOperation = "lighter";
        ctx.beginPath(); ctx.arc(0,0, 70, 0, Math.PI*2); ctx.fill();

        // Floating Title
        ctx.globalAlpha = Math.sin(Date.now() / 150) * 0.3 + 0.7;
        ctx.fillStyle = SPELLS[currentSpellIdx].secondary;
        ctx.font = "bold 32px Cinzel";
        ctx.textAlign = "center";
        ctx.shadowBlur = 15;
        ctx.shadowColor = SPELLS[currentSpellIdx].color;
        ctx.fillText("CHANNELING", 0, -140);
        
        ctx.restore();
    }

    function spawnWisp() {
        wisps.push({
            x: Math.random() * canvas.width,
            y: canvas.height + 20,
            size: Math.random() * 3 + 1,
            speed: Math.random() * 1 + 0.5,
            offset: Math.random() * 100,
            life: 1.0
        });
    }

    function spawnFireBreath(x, y) {
        const vx = (Math.random() - 0.5) * 15;
        const vy = Math.random() * 10 + 5; 
        particles.push(new Particle(x, y, vx, vy, { 
            color: "#ff4e00", 
            secondary: "#ffcc00", 
            type: 'fire' 
        }, 1.2));
    }

    function spawnProjectiles(x, y, vel, power) {
        for(let i=0; i<15; i++) {
            particles.push(new Particle(
                x, y, 
                vel.x * power + (Math.random()-0.5)*10, 
                vel.y * power + (Math.random()-0.5)*10, 
                SPELLS[currentSpellIdx], 
                2.0
            ));
        }
    }

    function spawnAmbient(x, y, count, vel, lifeMult) {
        for(let i=0; i<count; i++) {
            particles.push(new Particle(x + (Math.random()-0.5)*40, y + (Math.random()-0.5)*40, vel.x * 0.1 + (Math.random()-0.5)*4, vel.y * 0.1 + (Math.random()-0.5)*4, SPELLS[currentSpellIdx], lifeMult));
        }
    }

    class Particle {
        constructor(x, y, vx, vy, spell, life = 1.0) {
            this.x = x; this.y = y; this.vx = vx; this.vy = vy;
            this.spell = spell; this.life = life; this.maxLife = life;
            this.decay = 0.02 + Math.random() * 0.03;
            this.size = 6 + Math.random() * 10;
            this.rotation = Math.random() * Math.PI * 2;
            this.spin = (Math.random() - 0.5) * 0.2;
        }
        update() {
            this.x += this.vx; this.y += this.vy; this.rotation += this.spin; this.life -= this.decay;
            if (this.spell.type === 'fire') { this.vy += 0.2; this.vx *= 0.97; }
            else if (this.spell.type === 'rock') { this.vy += 0.3; this.vx *= 0.99; }
            else { this.vx *= 0.96; this.vy *= 0.96; }
        }
        draw() {
            const alpha = Math.max(0, this.life / this.maxLife);
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation); ctx.globalAlpha = alpha;
            if (this.spell.type === 'fire') {
                ctx.globalCompositeOperation = 'lighter';
                const grad = ctx.createRadialGradient(0,0,0,0,0, this.size * 2);
                grad.addColorStop(0, '#fff'); grad.addColorStop(0.3, this.spell.secondary); grad.addColorStop(0.6, this.spell.color); grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, this.size * 2, 0, Math.PI*2); ctx.fill();
            } else if (this.spell.type === 'rock') {
                ctx.fillStyle = "#444"; ctx.strokeStyle = this.spell.color; ctx.lineWidth = 1.5;
                ctx.beginPath(); for(let i=0; i<5; i++) { const r = (i%2==0 ? this.size : this.size*0.5); const ang = (i/5) * Math.PI * 2; ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r); }
                ctx.closePath(); ctx.fill(); ctx.stroke();
            } else {
                ctx.fillStyle = this.spell.color; ctx.shadowBlur = 10; ctx.shadowColor = this.spell.color; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
        }
    }

    async function initiate() {
        const btn = document.getElementById('init-btn');
        btn.disabled = true; btn.innerText = "ESTABLISHING LINK...";
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
            videoElement.srcObject = stream;
            videoElement.onloadedmetadata = () => videoElement.play();
            document.getElementById('gate').style.display = 'none';
            document.getElementById('app').style.display = 'block';
            new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                    await faceMesh.send({image: videoElement});
                }
            }).start();
            loop();
        } catch (e) { btn.disabled = false; btn.innerText = "LINK FAILED"; }
    }

    function loop() {
        if (canvas.width !== window.innerWidth) { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Somatic Detection Effect
        const handActive = handsState[0].active || handsState[1].active;
        vignette.style.opacity = handActive ? "1" : "0.5";

        // Render Camera Feed
        ctx.save(); 
        ctx.translate(canvas.width, 0); 
        ctx.scale(-1, 1); 
        // Adjusted transparency: face is much more visible now
        ctx.globalAlpha = mouthState.isOpen ? 0.35 : 0.65;
        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height); 
        ctx.restore();
        
        drawImmersiveElements();
        
        particles = particles.filter(p => p.life > 0);
        particles.forEach(p => { p.update(); p.draw(); });
        requestAnimationFrame(loop);
    }
</script>
</body>
</html>